TODO

CRIS
====

Arreglar el bug del input.
er de sacar la funcionalidad de los skills del player. O sea que cada skill tenga su propia funcionalidad. (heredando de Skill.cs)
Tratar de buscarle nombres a las variables confusa que autoexpliquen para que se usan. (ej: Load en el GameManager)
GameManager::Update() pasar a una corutina.
Animacion del principio todo en un script referenciado desde diferentes partes.

Eliminar difinitivamente EnemyCollision

RUSO
====

[Flags]
private enum States
{
	charged = 0,
	stunned
	stuck
	shot
}

int states = 0; //  00000000000100010

states |= 1<<charged; // = 00010

states |= 1<<stuck; // = 10000

00000000000100010

if (states & stuck == 0)
{
	
}



00001 
|
10000
=
10001


00001 
&
10000
=
00000


TODO
====
if (player1)
        {
            p1Instance.GetComponent<Palette>().isPlayer1 = true;
            p1Instance.transform.position = p1Position.transform.position;
            p1Light.transform.parent = p1Instance.transform;
            p1EXAnimator.SetTrigger("RESET");
            p1EXAnimator.SetInteger("MAX_CHARGES", p1Instance.GetComponent<Palette>().maxCharges);
            p1EXAnimator.SetInteger("CHARGES", 0);
            p1Instance.GetComponent<Palette>().UpdateCharges = P1UpdateCharges;
        }
        else
        {
            p2Instance.GetComponent<Palette>().isPlayer1 = false;
            p2Instance.transform.position = p2Position.transform.position;
            p2Instance.transform.Rotate(Vector3.back, 180.0f);
            p2Light.transform.parent = p2Instance.transform;
            p2EXAnimator.SetTrigger("RESET");
            p2EXAnimator.SetInteger("MAX_CHARGES", p2Instance.GetComponent<Palette>().maxCharges);
            p2EXAnimator.SetInteger("CHARGES", 0);
            p2Instance.GetComponent<Palette>().UpdateCharges = P2UpdateCharges;
        }
ESTO NOOOOOOOOO!
Generalizar de alguna manera, posiblemente usando algo asi:
[Serializable]
public class PlayerData
{
	public Animator EXAnimator;
	public SpriteRenderer NullBarFull;
	public KeyCode actionKeyCode;
}
public PlayerData[] playersDatas;

ballStartAngle = UnityEngine.Random.value * 360;


PATO
====

Exportar solo a garomo y crear un proyecto nuevo.

Agarrar el CharacterController Original y meterle el nivel a ver que pasa.

Probar estas cosas en diferentes compus.

Principalmente tratar de acotar los problemas. 

Sacar la tortuga de los slopes que queda requete horrible.

Investigar Todas las opciones de Physics 2D ;)


THEO
====

Ctrl + shift + F //Buscar en todos los archivos del proyecto

Remover en todos lados la diferenciacion entre player01 y player02

Poner como componente el input manager en cada player dejando solo una variable player y playerPvP.  

player1 = Instantiate(Players1[(int)player1_selected]).GetComponent<Player>(); //instancia el gameObject player y le pide el componete Playerdel objeto instanciado para luego guardarlo en "player1" (Remplazar esto en el DataCombatPvP.cs)

ver todos los scripts y encontrar los patrones en el codigo que simplifiquen el codiogo.

Unificar move left y move right.

Move left y move right son EXACTAMTENTE lo mismo solo que con un menos adelante.

cambioSpriteHabilitado = (((InputPlayerController.GetInputAxis(inputHorizontal) > 0 || InputPlayerController.GetInputAxis(inputHorizontalAnalog) > 0.9f) && InputPlayerController.GetInputAxis(inputVertical) == 0 && moveHorizontalPlayer) || player.enumsPlayers.movimiento == EnumsPlayers.Movimiento.MoverAdelante);
NOOOOO
Mathf.Abs(InputPlayerController.GetInputAxis(inputHorizontal)) > 0.9
SIIII

TRatar de no tener lineas de màs de 140 caracteres. Si tiene màs lo màs probable es que haya algo mal o raro. ES ILEGIBLE


    void Update()
    {
        CheckOutLimit();
        CheckDead(); //NO, checkea si se murio en el momento en que recive daño
        DelayEnableAttack();
        DelayEnableParabolaAttack();
        CheckMovementInSpecialAttack();
        CheckBoxColliders2D(); //NO, cada accion dice que box collider hay que apagar o prender (ej: cuando salto se prende el de salto y se apagan los demas)
    }
